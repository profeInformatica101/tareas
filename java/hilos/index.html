<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Programaci√≥n Multihilo en Java - Cena de los Fil√≥sofos</title>
    <!-- Bootstrap 5 desde CDN -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
</head>
<body class="bg-light">
<style>
    code{color:darkred;}
</style>
<nav class="navbar navbar-expand-lg navbar-dark bg-dark mb-4">
    <div class="container">
        <a class="navbar-brand" href="#">Multihilo en Java</a>
        <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
            <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarNav">
            <ul class="navbar-nav ms-auto">
                <li class="nav-item"><a class="nav-link" href="#filosofos">Problema</a></li>
                <li class="nav-item"><a class="nav-link" href="#teoria">Teor√≠a</a></li>
                <li class="nav-item"><a class="nav-link" href="#codigo">C√≥digo Java</a></li>
                <li class="nav-item"><a class="nav-link" href="#criterios">Criterios de evaluaci√≥n</a></li>
                <li class="nav-item"><a class="nav-link" href="#variantes">Variantes</a></li>
           <li class="nav-item"><a class="nav-link" href="#debugger">Depurador</a></li>
<li class="nav-item"><a class="nav-link" href="#pruebas">Pruebas unitarias</a></li>
                <li class="nav-item"><a class="nav-link" href="#entrega">Entrega</a></li>
            </ul>
        </div>
    </div>
</nav>

<div class="container">

    <!-- T√≠tulo -->
    <div class="row mb-4">
        <div class="col">
            <h1 class="mb-3">Programaci√≥n multihilo en Java: la cena de los fil√≥sofos</h1>
            <p class="lead">
                En este tutorial veremos c√≥mo programar una aplicaci√≥n multihilo en Java
                usando el problema cl√°sico de la <a href="https://es.wikipedia.org/wiki/Problema_de_la_cena_de_los_fil%C3%B3sofos"><mark>cena de los fil√≥sofos</mark></a> y c√≥mo se relaciona con
                los criterios de evaluaci√≥n del resultado de aprendizaje:
                <strong>‚ÄúDesarrolla aplicaciones compuestas por varios hilos de ejecuci√≥n‚Ä¶‚Äù</strong>
            </p>
        </div>
    </div>
   <!-- SECCI√ìN 0: EL PROBLEMA DE LA CENA DE LOS FIL√ìSOFOS -->
    <section id="filosofos" class="mb-5">
        <h2>0. El problema cl√°sico de la cena de los fil√≥sofos</h2>

        <div class="row mt-3">
            <div class="col-lg-7">
                <div class="card h-100 shadow-sm">
                    <div class="card-header bg-secondary text-white">
                        Planteamiento del problema
                    </div>
                    <div class="card-body">
                        <p>
                            El problema de la <strong>cena de los fil√≥sofos</strong>, propuesto por
                            Edsger Dijkstra, es uno de los ejemplos m√°s conocidos en programaci√≥n
                            concurrente. Sirve para estudiar c√≥mo varios procesos (o hilos)
                            compiten por recursos compartidos de forma segura.
                        </p>
                        <p>
                            Imaginamos una mesa redonda con <strong>N fil√≥sofos</strong> sentados
                            alrededor. Entre cada fil√≥sofo y su vecino hay un <strong>tenedor</strong>
                            (o palillo). Cada fil√≥sofo alterna entre dos actividades:
                            <strong>pensar</strong> y <strong>comer</strong>.
                        </p>
                        <ul>
                            <li>Para comer, un fil√≥sofo necesita tomar <strong>dos tenedores</strong>:
                                el de su izquierda y el de su derecha.</li>
                            <li>Los tenedores son <strong>recursos compartidos</strong>:
                                cada tenedor solo puede ser usado por un fil√≥sofo a la vez.</li>
                            <li>Mientras piensa, el fil√≥sofo no necesita tenedores.</li>
                        </ul>
                        
                        <p>
                            El reto consiste en dise√±ar un protocolo que permita que todos los fil√≥sofos
                            coman ‚Äúsuficientemente a menudo‚Äù, sin caer en problemas t√≠picos de la
                            concurrencia como el <em>interbloqueo</em> (<em>deadlock</em>),
                            la <em>inanici√≥n</em> (<em>starvation</em>) o las
                            <em>condiciones de carrera</em> (<em>race conditions</em>).
                        </p>
                    </div>
                      <img class="img-fluid rounded shadow" width="75%"
                         src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/7b/An_illustration_of_the_dining_philosophers_problem.png/960px-An_illustration_of_the_dining_philosophers_problem.png"
                         alt="Ilustraci√≥n del problema de los fil√≥sofos">
                </div>
            </div>

            <div class="col-lg-5 mt-3 mt-lg-0">
                <div class="card h-100 shadow-sm">
                    <div class="card-header bg-secondary text-white">
                        Interpretaci√≥n en t√©rminos de hilos y recursos
                    </div>
                    <div class="card-body">
                        <p>
                            En t√©rminos de programaci√≥n multihilo:
                        </p>
                        <ul>
                            <li>Cada <strong>fil√≥sofo</strong> se modela como un
                                <strong>hilo de ejecuci√≥n</strong> independiente.</li>
                            <li>Cada <strong>tenedor</strong> representa un
                                <strong>recurso compartido</strong> que no puede ser usado por
                                m√°s de un hilo a la vez.</li>
                            <li>La <strong>mesa</strong> y el protocolo que siguen los fil√≥sofos
                                se modelan como una <strong>estructura de sincronizaci√≥n</strong>
                                (monitor, sem√°foros, locks, etc.).</li>
                        </ul>

                        <img src="src/img/problema.png">
                        <p>
                            Una soluci√≥n correcta debe garantizar:
                        </p>
                        <ul>
                            <li><strong>Seguridad</strong>: nunca dos fil√≥sofos vecinos comen
                                simult√°neamente con el mismo tenedor.</li>
                            <li><strong>Ausencia de interbloqueo</strong>: el sistema no se queda
                                bloqueado para siempre.</li>
                            <li><strong>Equidad</strong>: ning√∫n fil√≥sofo se queda permanentemente
                                sin comer.</li>
                        </ul>
                        <p>
                            En este tutorial implementaremos primero una soluci√≥n basada en un
                            <strong>monitor</strong> en Java, y despu√©s veremos variantes m√°s
                            avanzadas usando <code>java.util.concurrent</code> y sem√°foros.
                        </p>
                    </div>
                </div>
            </div>
        </div>
    </section>
    <!-- SECCI√ìN 1: TEOR√çA -->
    <section id="teoria" class="mb-5">
        <h2>1. Teor√≠a b√°sica de programaci√≥n multihilo</h2>

        <div class="row row-cols-1 row-cols-md-2 g-4 mt-1">

            <!-- Contexto de ejecuci√≥n -->
            <div class="col">
                <div class="card h-100">
                    <div class="card-header bg-primary text-white">
                        Contexto de ejecuci√≥n de los hilos. Recursos compartidos
                    </div>
                    <div class="card-body">
                        <p>
                            Un <strong>hilo</strong> es una secuencia de instrucciones que se ejecuta de forma
                            (aparentemente) paralela a otras. Todos los hilos de un programa
                            comparten el mismo espacio de memoria y los mismos recursos
                            (objetos, ficheros, variables est√°ticas, etc.).
                        </p>
                        <p>
                            En la cena de los fil√≥sofos:
                            cada fil√≥sofo es un <strong>hilo</strong> y los <strong>tenedores/palillos</strong> son
                            recursos compartidos que varios hilos intentan usar al mismo tiempo.
                            En nuestra implementaci√≥n, esos recursos se gestionan a trav√©s de un
                            <strong>monitor</strong> que controla qui√©n puede comer y cu√°ndo.
                        </p>
                        <p>
                            Desde el punto de vista del sistema operativo, cada hilo dispone de su
                            propio <em>contexto de ejecuci√≥n</em> (contador de programa, pila, registros),
                            pero comparte el <em>espacio de direcciones</em>. Justamente esta compartici√≥n
                            de memoria es la que hace necesaria la sincronizaci√≥n cuando varios hilos
                            leen y escriben sobre las mismas estructuras de datos.
                        </p>
                    </div>
                  <img src="src/img/hilo.png">
                </div>
            </div>

            <!-- Estados de un hilo -->
            <div class="col">
                <div class="card h-100">
                    <div class="card-header bg-primary text-white">
                        Estados de un hilo. Cambios de estado
                    </div>
                    <div class="card-body">
                        <p>
                            Los hilos en Java pueden pasar por distintos estados:
                            <strong>NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED</strong>.
                        </p>
                        <ul>
                            <li><code>NEW</code>: se ha creado el hilo, pero a√∫n no se ha iniciado.</li>
                            <li><code>RUNNABLE</code>: listo para usar CPU (ejecut√°ndose o en cola).</li>
                            <li><code>BLOCKED/WAITING</code>: espera por un recurso o una condici√≥n.</li>
                            <li><code>TIMED_WAITING</code>: espera con tiempo l√≠mite (por ejemplo, <code>sleep()</code>).</li>
                            <li><code>TERMINATED</code>: el m√©todo <code>run()</code> ha terminado.</li>
                        </ul>
                        <p>
                            En la cena de los fil√≥sofos, los hilos pasan frecuentemente por
                            estados de <code>WAITING</code> y <code>TIMED_WAITING</code> al
                            esperar por tenedores o simular que piensan/comen.
                        </p>
                        <p>
                            Observar estos estados en el depurador (o imprimiendo trazas) ayuda
                            a comprender c√≥mo el planificador cambia de un hilo a otro y c√≥mo
                            las primitivas de sincronizaci√≥n (<code>wait()</code>, <code>notifyAll()</code>,
                            <code>sleep()</code>, adquisici√≥n de monitores y sem√°foros) generan
                            transiciones entre estados.
                        </p>
                    </div>
                    <img src="src/img/estados_hilos.JPG" alt="Estados de los hilos en Java">
                </div>
            </div>

            <!-- Librer√≠as y clases -->
            <div class="col">
                <div class="card h-100">
                    <div class="card-header bg-primary text-white">
                        Librer√≠as y clases para multihilo en Java
                    </div>
                    <div class="card-body">
                        <p>
                            Las clases b√°sicas para trabajar con hilos en Java son:
                        </p>
                        <ul>
                            <li><code>java.lang.Thread</code> (creaci√≥n y gesti√≥n directa de hilos).</li>
                            <li><code>java.lang.Runnable</code> (encapsula la tarea que ejecutar√° el hilo).</li>
                            <li>M√©todos como <code>start()</code>, <code>run()</code>, <code>sleep()</code>,
                                <code>interrupt()</code>.</li>
                        </ul>
                        <p>
                            Para sincronizaci√≥n y concurrencia avanzada tambi√©n existen
                            librer√≠as como <code>java.util.concurrent</code>, que proporcionan
                            abstracciones de m√°s alto nivel (colas bloqueantes, pools de hilos,
                            sem√°foros, locks, etc.). En la primera implementaci√≥n usaremos
                            principalmente las primitivas cl√°sicas
                            (<code>synchronized</code>, <code>wait()</code>, <code>notifyAll()</code>) y
                            en las variantes veremos soluciones equivalentes usando sem√°foros.
                        </p>
     <img class="img-fluid rounded shadow"
                         src="src/img/driagama_hilo.png"
                         alt="Diagrama UML Thread">
                        <h6 class="mt-3">Uso de <code>java.util.concurrent</code></h6>
                        <p>
                            La biblioteca <code>java.util.concurrent</code> introduce un modelo de
                            programaci√≥n por tareas:
                        </p>
                        <ul>
                            <li><code>ExecutorService</code>: gestiona un <em>pool</em> de hilos y permite
                                enviar tareas con <code>execute()</code> o <code>submit()</code>.</li>
                            <li><code>Callable&lt;T&gt;</code> y <code>Future&lt;T&gt;</code>: representan tareas
                                que devuelven un resultado y permiten recuperar el valor de forma
                                bloqueante (<code>get()</code>) o con timeout.</li>
                            <li><code>Semaphore</code>: contador que controla cu√°ntos hilos pueden acceder
                                simult√°neamente a un recurso.</li>
                            <li><code>Lock</code> y <code>ReentrantLock</code>: alternativa a
                                <code>synchronized</code> con m√°s operaciones (bloqueo con timeout,
                                comprobaci√≥n no bloqueante, etc.).</li>
                        </ul>
                        <p>
                            Estas abstracciones son preferibles a las primitivas b√°sicas cuando:
                        </p>
                        <ul>
                            <li>La aplicaci√≥n crea y destruye muchos hilos (es m√°s eficiente reutilizar
                                hilos con un <code>ExecutorService</code>).</li>
                            <li>Necesitamos cancelar tareas, esperar resultados o componer varias tareas.</li>
                            <li>Se requiere mayor control sobre la pol√≠tica de planificaci√≥n o sobre la
                                granularidad del bloqueo (<code>Lock</code> frente a <code>synchronized</code>).</li>
                            <li>Queremos expresar restricciones de concurrencia de forma expl√≠cita,
                                por ejemplo con <code>Semaphore</code> o con <code>ReadWriteLock</code>.</li>
                        </ul>
                        <p>
                            El patr√≥n de monitor que usamos en este tutorial se puede ver como una
                            versi√≥n manual de algunos de estos mecanismos, basada en el bloqueo
                            impl√≠cito de objetos y en variables condici√≥n implementadas con
                            <code>wait()</code> / <code>notifyAll()</code>.
                        </p>
                    </div>
               
                </div>
            </div>

            <!-- Gesti√≥n de hilos y prioridades -->
            <div class="col">
                <div class="card h-100">
                    <div class="card-header bg-primary text-white">
                        Gesti√≥n de hilos. Prioridades
                    </div>
                    <div class="card-body">
                        <p>
                            Los hilos pueden tener <strong>prioridades</strong> (de 1 a 10).
                            El planificador del sistema operativo suele dar m√°s tiempo de CPU a los hilos
                            con mayor prioridad, aunque <em>no est√° garantizado</em>.
                        </p>
                              <img class="img-fluid rounded shadow"
                         src="src/img/hilos_con_prioridad_spring_boot.png"
                         alt="Prioridad Spring Boot">
                        <p>
                            En Java podemos usar:
                        </p>
                        <pre class="bg-light p-2"><code>t.setPriority(Thread.NORM_PRIORITY + 1);</code></pre>
                        <p>
                            En la cena de los fil√≥sofos podr√≠amos dar m√°s prioridad a ciertos fil√≥sofos
                            para estudiar c√≥mo afecta al orden en que comen (y relacionarlo con problemas
                            de inanici√≥n).
                        </p>
                        <p>
                            En sistemas de producci√≥n se recomienda usar las prioridades con moderaci√≥n
                            y centrarse m√°s en el dise√±o de la sincronizaci√≥n y en el uso de
                            <code>ExecutorService</code>, ya que el comportamiento exacto de las
                            prioridades depende en gran medida del sistema operativo.
                        </p>
                    </div>
              
                </div>
            </div>

        </div>

        <!-- Sincronizaci√≥n -->
        <div class="col mt-4">
            <div class="card h-100">
                <div class="card-header bg-primary text-white">
                    Sincronizaci√≥n de hilos
                </div>
                <div class="card-body">
                    <p>
                        La <strong>sincronizaci√≥n</strong> evita que varios hilos accedan al mismo recurso
                        a la vez produciendo errores (condiciones de carrera).
                    </p>
                    <p>
                        En Java se usa:
                    </p>
                    <ul>
                        <li><code>synchronized</code> para proteger secciones cr√≠ticas.</li>
                        <li><code>wait()</code> para poner un hilo en espera mientras un recurso no est√° disponible.</li>
                        <li><code>notify()</code> / <code>notifyAll()</code> para despertar hilos que estaban esperando.</li>
                    </ul>
                    <img src="src/img/objeto.png" alt="Monitor en Java">
                    <p class="mt-2">
                        En nuestro problema, el <strong>monitor</strong> de fil√≥sofos usa estos mecanismos
                        para garantizar que solo los fil√≥sofos que puedan comer (sus vecinos no comen)
                        pasen al estado de COMIENDO. Cada llamada a <code>wait()</code> se asocia al
                        <em>intrinsic lock</em> del objeto monitor, y las llamadas a
                        <code>notifyAll()</code> despiertan a los fil√≥sofos que estaban bloqueados en
                        ese mismo monitor.
                    </p>
                    <p>
                        El patr√≥n de monitor implementa la idea de que todos los accesos al recurso
                        compartido se realizan a trav√©s de un objeto intermediario que:
                    </p>
                    <ul>
                        <li>Encapsula el estado compartido (en este caso, el array <code>estado[]</code>).</li>
                        <li>Define operaciones at√≥micas (<code>tomarTenedores</code>,
                            <code>dejarTenedores</code>) que mantienen las invariantes del sistema.</li>
                        <li>Usa variables condici√≥n (<code>wait()</code>/<code>notifyAll()</code>)
                            para suspender y reanudar hilos seg√∫n se cumplan ciertas condiciones l√≥gicas.</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Compartici√≥n de informaci√≥n y problemas -->
        <div class="col mt-4">
            <div class="card h-100">
                <div class="card-header bg-primary text-white">
                    Compartici√≥n de informaci√≥n y problemas
                </div>
                <div class="card-body">
                    <p>
                        Cuando varios hilos comparten informaci√≥n pueden aparecer:
                    </p>
                    <ul>
                        <li><strong>Condiciones de carrera</strong> (<em>race conditions</em>).</li>
                        <li><strong>Interbloqueo</strong> (<em>deadlock</em>).</li>
                        <li><strong>Inanici√≥n</strong> (<em>starvation</em>).</li>
                    </ul>

                    <h6>Condiciones de carrera</h6>
                    <p>
                        Una condici√≥n de carrera se da cuando el resultado final de un programa
                        depende del orden no controlado en que los hilos intercalan sus operaciones.
                        Por ejemplo, si dos hilos incrementan una misma variable <code>contador</code>
                        sin sincronizaci√≥n:
                    </p>
                    <pre class="bg-light p-2"><code>contador = contador + 1;</code></pre>
                    <p>
                        cada incremento puede leerse y escribirse de forma intercalada, produciendo
                        valores perdidos. En la cena de los fil√≥sofos, una condici√≥n de carrera
                        podr√≠a permitir que dos fil√≥sofos vecinos entren a la vez en estado COMIENDO
                        si el acceso a <code>estado[]</code> no se protegiera con
                        <code>synchronized</code>.
                    </p>

                    <h6>Interbloqueo (deadlock)</h6>
                    <img class="img-fluid rounded shadow my-2"
                         src="https://upload.wikimedia.org/wikipedia/commons/2/23/Deadlock_at_a_four-way-stop.gif"
                         alt="Deadlock tr√°fico">
                    <p>
                        Un <strong>deadlock</strong> se produce cuando un conjunto de hilos espera
                        indefinidamente por recursos que se encuentran retenidos por otros hilos del
                        propio conjunto. Cl√°sicamente se describe en t√©rminos de cuatro condiciones:
                        exclusi√≥n mutua, espera circular, retenci√≥n y espera, y no expropiaci√≥n.
                    </p>
                    <p>
                        La cena de los fil√≥sofos es un ejemplo can√≥nico: si todos los fil√≥sofos
                        toman primero el tenedor de la izquierda y esperan al de la derecha, se
                        forma un ciclo de dependencias que impide progresar. Nuestro monitor evita
                        este deadlock al garantizar que solo se asigna el estado COMIENDO cuando
                        ning√∫n vecino lo est√°, rompiendo la espera circular.
                    </p>

                    <h6>Inanici√≥n (starvation)</h6>
                    <p>
                        La <strong>inanici√≥n</strong> ocurre cuando un hilo nunca llega a acceder al
                        recurso, aunque te√≥ricamente podr√≠a hacerlo. Por ejemplo, si el planificador
                        siempre da prioridad a los mismos hilos, uno de ellos podr√≠a no comer nunca.
                    </p>
                    <p>
                        En el monitor de fil√≥sofos, la inanici√≥n se puede producir si la pol√≠tica de
                        despertar de hilos no es justa. Aunque <code>notifyAll()</code> despierta a
                        todos, la elecci√≥n de cu√°l adquiere el monitor a continuaci√≥n depende del
                        planificador. Las variantes con sem√°foros y con tiempo de espera ofrecen
                        estrategias adicionales para reducir o monitorizar la inanici√≥n.
                    </p>

                    <h6>C√≥mo ayuda el patr√≥n Monitor</h6>
                    <p>
                        El patr√≥n Monitor reduce estos problemas:
                    </p>
                    <ul>
                        <li>El <strong>estado compartido</strong> se encapsula y solo es accesible
                            a trav√©s de m√©todos sincronizados.</li>
                        <li>Las <strong>invariantes</strong> (por ejemplo, ‚Äúning√∫n fil√≥sofo come si
                            un vecino est√° comiendo‚Äù) se comprueban dentro del monitor antes de
                            modificar el estado.</li>
                        <li>Las <strong>variables condici√≥n</strong> permiten suspender hilos hasta
                            que la invariante vuelva a cumplirse, evitando bucles activos y uso
                            innecesario de CPU.</li>
                    </ul>
                    <p>
                        Aun as√≠, el patr√≥n monitor no garantiza por s√≠ solo la ausencia de deadlocks
                        o inanici√≥n: es el dise√±ador quien debe escoger correctamente el orden de
                        adquisici√≥n de recursos y las condiciones de activaci√≥n de los hilos.
                    </p>
                </div>
            </div>
        </div>

    </section>

    <!-- SECCI√ìN 2: C√ìDIGO JAVA -->
    <section id="codigo" class="mb-5">
        <h2>2. Implementaci√≥n en Java de la cena de los fil√≥sofos (Monitor)</h2>
        <p>
            A continuaci√≥n se muestra una implementaci√≥n en Java basada en un
            <strong>monitor</strong> que controla el estado de cada fil√≥sofo:
            <code>PENSANDO (0)</code>, <code>HAMBRIENTO (1)</code> y <code>COMIENDO (2)</code>.
            Esta versi√≥n se inspira en soluciones cl√°sicas en C, adaptadas a Java con
            <code>synchronized</code>, <code>wait()</code> y <code>notifyAll()</code>, y sigue
            buenas pr√°cticas de programaci√≥n concurrente (inmutabilidad de la configuraci√≥n,
            encapsulaci√≥n del estado y manejo correcto de interrupciones).
        </p>
        <h6>Diagrama de Clases</h6>
<img src="src/img/Clase_filosofo.png">
<h6>Diagrama Secuencia</h6>
<img src="src/img/diagrama_secuencia.png">
<h6>Diagrama de Estados</h6>
<img src="src/img/diagrama_estado.png">


        <h3 class="mt-3">2.1. Clase <code>MonitorFilosofos</code> (monitor de sincronizaci√≥n)</h3>
        <pre class="bg-dark text-light p-3 small"><code>/**
 * Monitor de sincronizaci√≥n para el problema de la cena de los fil√≥sofos.
 * Encapsula el estado de cada fil√≥sofo y garantiza que solo puede comer
 * un fil√≥sofo cuyos vecinos no est√©n comiendo.
 */
public final class MonitorFilosofos {

    public static final int PENSANDO  = 0;
    public static final int HAMBRIENTO = 1;
    public static final int COMIENDO  = 2;

    private final int numFilosofos;

    // Estados: 0 = PENSANDO, 1 = HAMBRIENTO, 2 = COMIENDO
    private final int[] estado;

    /**
     * Crea un monitor para N fil√≥sofos.
     *
     * @param numFilosofos n√∫mero de fil√≥sofos (N &gt; 1)
     */
    public MonitorFilosofos(final int numFilosofos) {
        if (numFilosofos &lt;= 1) {
            throw new IllegalArgumentException("Debe haber al menos dos fil√≥sofos");
        }
        this.numFilosofos = numFilosofos;
        this.estado = new int[numFilosofos];
        for (int i = 0; i &lt; numFilosofos; i++) {
            estado[i] = PENSANDO; // todos empiezan pensando
        }
    }

    public int getNumFilosofos() {
        return numFilosofos;
    }

    private int izquierda(final int i) {
        return (i + numFilosofos - 1) % numFilosofos;
    }

    private int derecha(final int i) {
        return (i + 1) % numFilosofos;
    }

    private void cambiarEstado(final int i, final int nuevo) {
        estado[i] = nuevo;
    }

    private int estadoIzq(final int i) {
        return estado[izquierda(i)];
    }

    private int estadoDer(final int i) {
        return estado[derecha(i)];
    }

    /**
     * Intenta que el fil√≥sofo i pase a estado COMIENDO si sus vecinos
     * no est√°n comiendo. Este m√©todo debe llamarse siempre con el monitor
     * adquirido (dentro de un m√©todo synchronized).
     */
    private void intentarComer(final int i) {
        if (estado[i] == HAMBRIENTO
                &amp;&amp; estadoIzq(i) != COMIENDO
                &amp;&amp; estadoDer(i) != COMIENDO) {
            cambiarEstado(i, COMIENDO);
            // Despertamos a todos para que los fil√≥sofos que estaban
            // esperando puedan reevaluar su condici√≥n.
            notifyAll();
        }
    }

    /**
     * Fil√≥sofo i se declara hambriento e intenta comer. Si no puede,
     * el hilo queda bloqueado (WAITING) hasta que pueda pasar a COMIENDO.
     *
     * @param i √≠ndice del fil√≥sofo (0..N-1)
     * @throws InterruptedException si el hilo es interrumpido mientras espera
     */
    public synchronized void tomarTenedores(final int i) throws InterruptedException {
        cambiarEstado(i, HAMBRIENTO);
        intentarComer(i);

        // Si no ha podido empezar a comer, espera hasta que su estado sea COMIENDO
        while (estado[i] != COMIENDO) {
            wait(); // pasa a estado WAITING asociado a este monitor
        }
    }

    /**
     * Fil√≥sofo i deja de comer y pasa a pensar. Despu√©s de liberar los
     * tenedores, permite que sus vecinos intenten comer.
     *
     * @param i √≠ndice del fil√≥sofo (0..N-1)
     */
    public synchronized void dejarTenedores(final int i) {
        cambiarEstado(i, PENSANDO);
        // Sus vecinos pueden intentar comer ahora que i ha dejado los tenedores.
        intentarComer(izquierda(i));
        intentarComer(derecha(i));
        notifyAll();
    }

    /**
     * Solo para depuraci√≥n o para mostrar el estado en una interfaz gr√°fica.
     *
     * @param i √≠ndice del fil√≥sofo
     * @return estado del fil√≥sofo i
     */
    public synchronized int getEstado(final int i) {
        return estado[i];
    }
}</code></pre>

        <h3 class="mt-4">2.2. Clase <code>Filosofo</code> (hilo que usa el monitor)</h3>
        <pre class="bg-dark text-light p-3 small"><code>import java.util.Random;

/**
 * Representa a un fil√≥sofo que piensa y come de forma repetida.
 * Cada fil√≥sofo es un hilo que coordina su acceso a los tenedores
 * a trav√©s del MonitorFilosofos.
 */
public final class Filosofo implements Runnable {

    private final int id;
    private final MonitorFilosofos monitor;
    private final Random random = new Random();

    public Filosofo(final int id, final MonitorFilosofos monitor) {
        this.id = id;
        this.monitor = monitor;
    }

    private void pensar() throws InterruptedException {
        System.out.println("Fil√≥sofo " + id + " PENSANDO...");
        // Simulamos un tiempo variable de pensamiento (TIMED_WAITING)
        Thread.sleep(random.nextInt(2000) + 500L);
    }

    private void comer() throws InterruptedException {
        System.out.println("Fil√≥sofo " + id + " COMIENDO üçù");
        Thread.sleep(random.nextInt(2000) + 500L);
    }

    @Override
    public void run() {
        try {
            while (!Thread.currentThread().isInterrupted()) {
                pensar();
                System.out.println("Fil√≥sofo " + id + " tiene HAMBRE.");
                // Puede quedar en estado WAITING dentro del monitor
                monitor.tomarTenedores(id);
                comer();
                monitor.dejarTenedores(id);
            }
        } catch (InterruptedException e) {
            // Restablecemos el estado de interrupci√≥n y salimos del bucle
            Thread.currentThread().interrupt();
            System.out.println("Fil√≥sofo " + id + " interrumpido. Termina su ejecuci√≥n.");
        }
    }
}</code></pre>

        <h3 class="mt-4">2.3. Clase <code>CenaFilosofos</code> (m√©todo <code>main</code>)</h3>
        <pre class="bg-dark text-light p-3 small"><code>/**
 * Punto de entrada de la aplicaci√≥n. Crea N fil√≥sofos y un monitor
 * compartido para coordinar el acceso a los recursos (tenedores).
 */
public final class CenaFilosofos {

    private CenaFilosofos() {
        // Evitamos instanciaci√≥n
    }

    public static void main(String[] args) {
        final int N = 5;
        final MonitorFilosofos monitor = new MonitorFilosofos(N);

        for (int i = 0; i &lt; N; i++) {
            final Filosofo f = new Filosofo(i, monitor);
            final Thread t = new Thread(f, "Filosofo-" + i);

            // Opcional: prioridad para trabajar el criterio g)
            // t.setPriority(Thread.NORM_PRIORITY + (i % 2));

            t.start(); // el hilo pasa de NEW a RUNNABLE
        }
    }
}</code></pre>

        <p class="mt-3">
            Para ejecutar el programa:
        </p>
        <pre class="bg-light p-2"><code>javac MonitorFilosofos.java Filosofo.java CenaFilosofos.java
java CenaFilosofos</code></pre>

    </section>

    <!-- SECCI√ìN 3: CRITERIOS DE EVALUACI√ìN -->
    <section id="criterios" class="mb-5">
        <h2>3. Relaci√≥n con los criterios de evaluaci√≥n</h2>
        <p>
            A continuaci√≥n se explica c√≥mo este caso pr√°ctico y la teor√≠a anterior permiten
            trabajar cada criterio del resultado de aprendizaje
            <strong>‚ÄúDesarrolla aplicaciones compuestas por varios hilos de ejecuci√≥n‚Ä¶‚Äù</strong>.
            Adem√°s de la descripci√≥n conceptual, se indican las clases y m√©todos concretos
            en los que se evidencia cada criterio.
        </p>

        <div class="accordion mt-3" id="accordionCriterios">

            <!-- a) -->
            <div class="accordion-item">
                <h2 class="accordion-header" id="critA">
                    <button class="accordion-button" type="button" data-bs-toggle="collapse"
                            data-bs-target="#collapseA">
                        a) Identificaci√≥n de situaciones en las que resulta √∫til la utilizaci√≥n de varios hilos
                    </button>
                </h2>
                <div id="collapseA" class="accordion-collapse collapse show" data-bs-parent="#accordionCriterios">
                    <div class="accordion-body">
                        <p>
                            La cena de los fil√≥sofos representa una situaci√≥n donde varias tareas deben
                            ejecutarse simult√°neamente: cada fil√≥sofo piensa y quiere comer a su ritmo.
                            Si se hiciera con un √∫nico hilo, la simulaci√≥n ser√≠a irreal (los fil√≥sofos
                            actuar√≠an uno detr√°s de otro).
                        </p>
                        <p>
                            Conceptos te√≥ricos relacionados:
                            <strong>contexto de ejecuci√≥n de los hilos, recursos compartidos</strong>.
                        </p>
                        <p>
                            T√©cnicamente, este criterio se materializa cuando el dise√±o separa la
                            l√≥gica de cada fil√≥sofo (clase <code>Filosofo</code>, que implementa
                            <code>Runnable</code>) del recurso compartido
                            (<code>MonitorFilosofos</code>). El hecho de que el <code>main</code>
                            cree un hilo por cada fil√≥sofo (<code>new Thread(f, "Filosofo-" + i)</code>)
                            indica que la soluci√≥n reconoce expl√≠citamente que cada fil√≥sofo es una
                            unidad de ejecuci√≥n independiente que se beneficia del paralelismo.
                        </p>
                    </div>
                </div>
            </div>

            <!-- b) -->
            <div class="accordion-item">
                <h2 class="accordion-header" id="critB">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                            data-bs-target="#collapseB">
                        b) Reconocimiento de mecanismos para crear, iniciar y finalizar hilos
                    </button>
                </h2>
                <div id="collapseB" class="accordion-collapse collapse" data-bs-parent="#accordionCriterios">
                    <div class="accordion-body">
                        <p>
                            En la clase <code>CenaFilosofos</code> se crean hilos con:
                        </p>
                        <pre class="bg-light p-2"><code>final Filosofo f = new Filosofo(i, monitor);
final Thread t = new Thread(f, "Filosofo-" + i);
t.start();</code></pre>
                        <p>
                            Aqu√≠ el alumnado reconoce el uso de <code>Thread</code>, el m√©todo
                            <code>start()</code> y la interfaz <code>Runnable</code>.
                            La finalizaci√≥n controlada se puede trabajar introduciendo
                            un n√∫mero m√°ximo de ciclos o usando <code>interrupt()</code>.
                        </p>
                        <p>
                            Relaci√≥n con la teor√≠a:
                            <strong>librer√≠as y clases, estados del hilo (NEW, RUNNABLE, TERMINATED)</strong>.
                        </p>
                        <p>
                            Este criterio tambi√©n queda reflejado en la gesti√≥n de interrupciones en
                            <code>Filosofo.run()</code>. El bloque <code>catch (InterruptedException e)</code>
                            restablece el estado de interrupci√≥n y termina el bucle, mostrando un
                            mensaje de fin de ejecuci√≥n. Con ello el alumno aprende a terminar
                            limpiamente un hilo multihilo sin recurrir a m√©todos obsoletos como
                            <code>stop()</code>.
                        </p>
                    </div>
                </div>
            </div>

            <!-- c) -->
            <div class="accordion-item">
                <h2 class="accordion-header" id="critC">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                            data-bs-target="#collapseC">
                        c) Programaci√≥n de aplicaciones que implementen varios hilos
                    </button>
                </h2>
                <div id="collapseC" class="accordion-collapse collapse" data-bs-parent="#accordionCriterios">
                    <div class="accordion-body">
                        <p>
                            El programa implementa <strong>varios hilos reales</strong> (uno por fil√≥sofo)
                            que ejecutan c√≥digo concurrente en el m√©todo <code>run()</code>.
                        </p>
                        <p>
                            El alumnado no solo ve un ejemplo te√≥rico, sino una aplicaci√≥n funcional
                            de programaci√≥n multihilo.
                        </p>
                        <p>
                            Relaci√≥n con la teor√≠a:
                            <strong>programaci√≥n de aplicaciones multihilo</strong>.
                        </p>
                        <p>
                            Desde el punto de vista del c√≥digo, este criterio se evidencia en la
                            implementaci√≥n de la interfaz <code>Runnable</code> en
                            <code>Filosofo</code> y en el bucle infinito (condicionado por la
                            interrupci√≥n) dentro de <code>run()</code>. Cada iteraci√≥n del bucle
                            ejecuta la secuencia <code>pensar() ‚Üí tomarTenedores() ‚Üí comer() ‚Üí
                            dejarTenedores()</code>, mostrando una aplicaci√≥n completa con
                            comportamiento concurrente observable en consola.
                        </p>
                    </div>
                </div>
            </div>

            <!-- d) -->
            <div class="accordion-item">
                <h2 class="accordion-header" id="critD">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                            data-bs-target="#collapseD">
                        d) Identificaci√≥n de los posibles estados de ejecuci√≥n de un hilo y programaci√≥n de aplicaciones que los gestionen
                    </button>
                </h2>
                <div id="collapseD" class="accordion-collapse collapse" data-bs-parent="#accordionCriterios">
                    <div class="accordion-body">
                        <p>
                            Los estados se observan en el c√≥digo:
                        </p>
                        <ul>
                            <li><strong>NEW</strong>: al crear <code>Thread t = new Thread(...)</code>.</li>
                            <li><strong>RUNNABLE</strong>: tras llamar a <code>t.start()</code>.</li>
                            <li><strong>TIMED_WAITING</strong>: al usar <code>Thread.sleep()</code> en
                                <code>pensar()</code> y <code>comer()</code>.
                            </li>
                            <li><strong>WAITING</strong>: dentro de <code>MonitorFilosofos.tomarTenedores()</code> con
                                <code>wait()</code> cuando no puede comer a√∫n.
                            </li>
                            <li><strong>TERMINATED</strong>: cuando el m√©todo <code>run()</code> termina
                                (o se interrumpe).
                            </li>
                        </ul>
                        <p>
                            Relaci√≥n con la teor√≠a:
                            <strong>estados de un hilo, cambios de estado</strong>.
                        </p>
                        <p>
                            La propia l√≥gica de sincronizaci√≥n del monitor muestra una gesti√≥n
                            consciente de estos estados: al entrar en
                            <code>tomarTenedores()</code>, el hilo adquiere el monitor (pasa a
                            <em>BLOCKED</em> si otro fil√≥sofo lo posee), cambia su estado l√≥gico a
                            <code>HAMBRIENTO</code> y, si no puede comer, ejecuta <code>wait()</code>,
                            pasando a <em>WAITING</em>. Cuando otro fil√≥sofo libera los tenedores y
                            ejecuta <code>notifyAll()</code>, el hilo despierta y vuelve a
                            <em>RUNNABLE</em>, reintentando la condici√≥n del bucle <code>while</code>.
                        </p>
                    </div>
                </div>
            </div>

            <!-- e) -->
            <div class="accordion-item">
                <h2 class="accordion-header" id="critE">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                            data-bs-target="#collapseE">
                        e) Utilizaci√≥n de mecanismos para compartir informaci√≥n entre varios hilos de un mismo proceso
                    </button>
                </h2>
                <div id="collapseE" class="accordion-collapse collapse" data-bs-parent="#accordionCriterios">
                    <div class="accordion-body">
                        <p>
                            La clase <code>MonitorFilosofos</code> act√∫a como recurso compartido.
                            Todos los fil√≥sofos (hilos) acceden al mismo array <code>estado[]</code> y a
                            los m√©todos <code>tomarTenedores()</code> y <code>dejarTenedores()</code>,
                            que est√°n protegidos con <code>synchronized</code>.
                        </p>
                        <p>
                            Relaci√≥n con la teor√≠a:
                            <strong>recursos compartidos, compartici√≥n de informaci√≥n</strong>.
                        </p>
                        <p>
                            En t√©rminos de dise√±o, este criterio se refleja en c√≥mo se pasa la misma
                            instancia de <code>MonitorFilosofos monitor</code> al constructor de cada
                            <code>Filosofo</code>. No se duplican los recursos (tenedores) por hilo,
                            sino que se centraliza su gesti√≥n en un √∫nico objeto. La sincronizaci√≥n
                            sobre <code>this</code> dentro de los m√©todos del monitor garantiza que
                            las lecturas y escrituras sobre <code>estado[]</code> se realizan con
                            exclusi√≥n mutua y memoria coherente.
                        </p>
                    </div>
                </div>
            </div>

            <!-- f) -->
            <div class="accordion-item">
                <h2 class="accordion-header" id="critF">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                            data-bs-target="#collapseF">
                        f) Desarrollo de programas formados por varios hilos sincronizados mediante t√©cnicas espec√≠ficas
                    </button>
                </h2>
                <div id="collapseF" class="accordion-collapse collapse" data-bs-parent="#accordionCriterios">
                    <div class="accordion-body">
                        <p>
                            La sincronizaci√≥n se consigue con:
                        </p>
                        <ul>
                            <li><code>synchronized</code> en los m√©todos del monitor.</li>
                            <li><code>wait()</code> y <code>notifyAll()</code> para gestionar la espera por los recursos.</li>
                            <li>L√≥gica de vecinos (<code>intentarComer()</code>) que garantiza que solo
                                un fil√≥sofo coma cuando sus vecinos no est√°n comiendo.</li>
                        </ul>
                        <p>
                            Relaci√≥n con la teor√≠a:
                            <strong>sincronizaci√≥n de hilos, problemas de compartici√≥n</strong>.
                        </p>
                        <p>
                            Espec√≠ficamente, el m√©todo <code>tomarTenedores(int i)</code> ilustra el
                            uso de una <strong>variable de condici√≥n</strong> codificada como un
                            bucle <code>while</code> alrededor de <code>wait()</code>. Esto implementa
                            el patr√≥n ‚Äú<em>check-then-sleep</em>‚Äù, que garantiza que el hilo solo
                            avanza cuando se cumplen las condiciones l√≥gicas de seguridad. La
                            combinaci√≥n de este patr√≥n con <code>intentarComer(i)</code> y
                            <code>dejarTenedores(i)</code> constituye una soluci√≥n completa basada
                            en monitores para la sincronizaci√≥n de los hilos.
                        </p>
                    </div>
                </div>
            </div>

            <!-- g) -->
            <div class="accordion-item">
                <h2 class="accordion-header" id="critG">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                            data-bs-target="#collapseG">
                        g) Establecimiento y control de la prioridad de cada uno de los hilos de ejecuci√≥n
                    </button>
                </h2>
                <div id="collapseG" class="accordion-collapse collapse" data-bs-parent="#accordionCriterios">
                    <div class="accordion-body">
                        <p>
                            En la clase <code>CenaFilosofos</code> se puede activar el c√≥digo comentado:
                        </p>
                        <pre class="bg-light p-2"><code>t.setPriority(Thread.NORM_PRIORITY + (i % 2));</code></pre>
                        <p>
                            As√≠ parte del alumnado puede experimentar con diferentes prioridades y observar
                            si alg√∫n fil√≥sofo come m√°s veces que otros (posible inanici√≥n).
                        </p>
                        <p>
                            Relaci√≥n con la teor√≠a:
                            <strong>gesti√≥n de hilos y prioridades</strong>.
                        </p>
                        <p>
                            Desde el punto de vista t√©cnico, modificar las prioridades antes de llamar
                            a <code>start()</code> permite estudiar c√≥mo el planificador del sistema
                            operativo distribuye la CPU. Aunque el est√°ndar de Java no garantiza un
                            comportamiento determinista, el experimento es √∫til para reflexionar sobre
                            la relaci√≥n entre la capa de aplicaci√≥n (decisi√≥n de prioridades en
                            <code>CenaFilosofos</code>) y la capa de ejecuci√≥n (planificador real),
                            y sobre los riesgos de provocar starving si se abusa de prioridades altas.
                        </p>
                    </div>
                </div>
            </div>

            <!-- h) -->
            <div class="accordion-item">
                <h2 class="accordion-header" id="critH">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                            data-bs-target="#collapseH">
                        h) Depuraci√≥n y documentaci√≥n de los programas desarrollados
                    </button>
                </h2>
                <div id="collapseH" class="accordion-collapse collapse" data-bs-parent="#accordionCriterios">
                    <div class="accordion-body">
                        <p>
                            El c√≥digo est√° documentado con comentarios y mensajes por consola.
                            El alumnado puede:
                        </p>
                        <ul>
                            <li>Seguir la traza de cada hilo (fil√≥sofo).</li>
                            <li>Usar puntos de ruptura en el depurador.</li>
                            <li>Detectar posibles situaciones de bloqueo si se modifica la l√≥gica del monitor.</li>
                        </ul>
                        <p>
                            Relaci√≥n con la teor√≠a:
                            <strong>programaci√≥n de aplicaciones multihilo</strong> y buenas pr√°cticas.
                        </p>
                        <p>
                            Las cabeceras de clase y m√©todo en <code>MonitorFilosofos</code>,
                            <code>Filosofo</code> y <code>CenaFilosofos</code> siguen un estilo de
                            documentaci√≥n tipo Javadoc, lo que facilita la generaci√≥n autom√°tica de
                            documentaci√≥n t√©cnica. Adem√°s, los mensajes explicativos en
                            <code>System.out.println()</code> permiten depurar la ejecuci√≥n concurrente
                            sin necesidad de herramientas externas, algo especialmente √∫til en
                            entornos docentes o en ejercicios de laboratorio.
                        </p>
                    </div>
                </div>
            </div>

            <!-- i) -->
            <div class="accordion-item">
                <h2 class="accordion-header" id="critI">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                            data-bs-target="#collapseI">
                        i) An√°lisis del contexto de ejecuci√≥n de los hilos
                    </button>
                </h2>
                <div id="collapseI" class="accordion-collapse collapse" data-bs-parent="#accordionCriterios">
                    <div class="accordion-body">
                        <p>
                            El alumnado puede observar c√≥mo el sistema operativo reparte la CPU
                            entre los hilos seg√∫n el planificador y las prioridades.
                            Al ejecutar varias veces, el orden en que los fil√≥sofos comen
                            cambia, lo que permite comentar el contexto de ejecuci√≥n real:
                            cambios de contexto, planificaci√≥n, etc.
                        </p>
                        <p>
                            Relaci√≥n con la teor√≠a:
                            <strong>contexto de ejecuci√≥n de los hilos</strong>.
                        </p>
                    </div>
                </div>
            </div>

            <!-- j) -->
            <div class="accordion-item">
                <h2 class="accordion-header" id="critJ">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                            data-bs-target="#collapseJ">
                        j) An√°lisis de librer√≠as espec√≠ficas del lenguaje de programaci√≥n que permiten la programaci√≥n multihilo
                    </button>
                </h2>
                <div id="collapseJ" class="accordion-collapse collapse" data-bs-parent="#accordionCriterios">
                    <div class="accordion-body">
                        <p>
                            En el ejemplo se utilizan las librer√≠as b√°sicas:
                            <code>java.lang.Thread</code>, <code>java.lang.Runnable</code> y los
                            m√©todos de la clase <code>Object</code> (<code>wait()</code>,
                            <code>notifyAll()</code>).
                        </p>
                        <p>
                            En las variantes se introduce tambi√©n <code>java.util.concurrent.Semaphore</code>
                            para mostrar soluciones m√°s avanzadas.
                        </p>
                        <p>
                            Relaci√≥n con la teor√≠a:
                            <strong>librer√≠as y clases de programaci√≥n multihilo</strong>.
                        </p>
                    </div>
                </div>
            </div>

            <!-- k) -->
            <div class="accordion-item">
                <h2 class="accordion-header" id="critK">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                            data-bs-target="#collapseK">
                        k) Reconocimiento de los problemas derivados de la compartici√≥n de informaci√≥n entre los hilos de un mismo proceso
                    </button>
                </h2>
                <div id="collapseK" class="accordion-collapse collapse" data-bs-parent="#accordionCriterios">
                    <div class="accordion-body">
                        <p>
                            Si se elimina la sincronizaci√≥n (por ejemplo, se quita
                            <code>synchronized</code> y <code>wait()</code>/<code>notifyAll()</code> del monitor),
                            aparecen errores:
                        </p>
                        <ul>
                            <li>Varios fil√≥sofos podr√≠an entrar en estado de COMIENDO simult√°neamente sin respetar la l√≥gica de vecinos.</li>
                            <li>Aparecen condiciones de carrera y resultados incoherentes.</li>
                            <li>Puede producirse interbloqueo si todos esperan indefinidamente.</li>
                        </ul>
                        <p>
                            Esto permite reconocer y discutir los problemas cl√°sicos de
                            compartici√≥n de informaci√≥n.
                        </p>
                        <p>
                            Relaci√≥n con la teor√≠a:
                            <strong>compartici√≥n de informaci√≥n entre hilos. Problemas derivados</strong>.
                        </p>
                    </div>
                </div>
            </div>

        </div>

    </section>

    <!-- SECCI√ìN 4: VARIANTES Y EXTENSIONES -->
    <section id="variantes" class="mb-5">
        <h2>4. Variantes y extensiones del problema de los fil√≥sofos</h2>
        <p>
            El problema de los cinco fil√≥sofos tiene diversas variantes que permiten explorar
            soluciones m√°s complejas a los desaf√≠os de sincronizaci√≥n y concurrencia en sistemas
            distribuidos. A continuaci√≥n se presentan algunas de ellas con ejemplos en Java.
        </p>

        <!-- Variante 1: Portero -->
        <div class="card mb-4">
            <div class="card-header bg-success text-white">
                4.1. Variante del Portero o "Footman" sobre el monitor
            </div>
            <div class="card-body">
                <p>
                    En esta variante se introduce un <strong>portero</strong> que solo permite
                    que se sienten a la mesa como m√°ximo cuatro fil√≥sofos a la vez.
                    Esta restricci√≥n reduce las probabilidades de interbloqueo, ya que siempre
                    hay al menos un fil√≥sofo que podr√≠a acceder a ambos tenedores.
                </p>
                <p>
                    En Java podemos implementar este portero usando un
                    <code>Semaphore</code> de la biblioteca <code>java.util.concurrent</code>:
                </p>
                <pre class="bg-dark text-light p-3 small"><code>import java.util.concurrent.Semaphore;

/**
 * Envuelve al MonitorFilosofos a√±adiendo un "portero" (footman)
 * que limita el n√∫mero de fil√≥sofos que se sientan simult√°neamente.
 */
public final class MonitorConFootman {

    private static final int MAX_SENTADOS = 4;

    private final MonitorFilosofos monitor;
    private final Semaphore footman = new Semaphore(MAX_SENTADOS, true); // fairness=true

    public MonitorConFootman(final MonitorFilosofos monitor) {
        this.monitor = monitor;
    }

    public void sentarse(final int i) throws InterruptedException {
        // El portero limita el n√∫mero de fil√≥sofos concurrentemente sentados
        footman.acquire();   // espera si ya hay MAX_SENTADOS fil√≥sofos sentados
        monitor.tomarTenedores(i);
    }

    public void levantarse(final int i) {
        monitor.dejarTenedores(i);
        footman.release();   // libera un sitio en la mesa
    }
}</code></pre>

                <p>
                    El fil√≥sofo ahora usa el monitor con portero:
                </p>
                <pre class="bg-dark text-light p-3 small"><code>public final class FilosofoFootman implements Runnable {

    private final int id;
    private final MonitorConFootman monitor;

    public FilosofoFootman(final int id, final MonitorConFootman monitor) {
        this.id = id;
        this.monitor = monitor;
    }

    @Override
    public void run() {
        try {
            while (!Thread.currentThread().isInterrupted()) {
                // pensar...
                System.out.println("Fil√≥sofo " + id + " PENSANDO (footman)...");
                Thread.sleep(1000L);

                monitor.sentarse(id);
                System.out.println("Fil√≥sofo " + id + " COMIENDO (footman) üçù");
                Thread.sleep(1000L);
                monitor.levantarse(id);
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}</code></pre>

                <p>
                    Esta variante muestra c√≥mo una peque√±a restricci√≥n en el acceso a los recursos
                    puede mejorar significativamente la seguridad y eficiencia en concurrencia.
                    El sem√°foro act√∫a como un contador de plazas disponibles en la mesa, mientras
                    que la l√≥gica de vecinos sigue delegada en <code>MonitorFilosofos</code>.
                </p>
            </div>
        </div>

        <!-- Variante 2: Temporizadores aleatorios -->
        <div class="card mb-4">
            <div class="card-header bg-warning">
                4.2. Uso de temporizadores aleatorios para evitar el interbloqueo
            </div>
            <div class="card-body">
                <p>
                    Otra soluci√≥n consiste en permitir que cada fil√≥sofo suelte los tenedores
                    despu√©s de esperar un tiempo aleatorio si no puede obtener ambos.
                    Esto simula una espera probabil√≠stica que reduce la posibilidad de interbloqueo
                    y se utiliza en sistemas donde los procesos deben ceder los recursos
                    temporalmente si no logran completar su tarea en un per√≠odo espec√≠fico.
                </p>
                <p>
                    Ejemplo de l√≥gica con tiempo m√°ximo de intento:
                </p>
                <pre class="bg-dark text-light p-3 small"><code>import java.util.Random;

public final class FilosofoTimeout implements Runnable {

    private final int id;
    private final MonitorFilosofos monitor;
    private final Random random = new Random();

    public FilosofoTimeout(final int id, final MonitorFilosofos monitor) {
        this.id = id;
        this.monitor = monitor;
    }

    @Override
    public void run() {
        try {
            while (!Thread.currentThread().isInterrupted()) {
                // Pensar
                Thread.sleep(1000L);

                long inicio = System.currentTimeMillis();
                long timeout = 2000L + random.nextInt(2000);

                monitor.tomarTenedores(id);

                // Si no llega a COMER en cierto tiempo, suelta los tenedores
                while (monitor.getEstado(id) != MonitorFilosofos.COMIENDO) {
                    if (System.currentTimeMillis() - inicio &gt; timeout) {
                        System.out.println("Fil√≥sofo " + id
                                + " se rinde y vuelve a pensar (timeout).");
                        monitor.dejarTenedores(id);
                        break;
                    }
                    Thread.sleep(50L);
                }

                if (monitor.getEstado(id) == MonitorFilosofos.COMIENDO) {
                    // Comer normalmente
                    Thread.sleep(1000L);
                    monitor.dejarTenedores(id);
                }
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}</code></pre>

                <p>
                    Esta t√©cnica es √∫til en sistemas distribuidos donde los procesos tienen
                    diferentes prioridades y tiempos de espera, y se desea evitar bloqueos largos.
                </p>
            </div>
        </div>

        <!-- Variante 3: Modelo Pensar-Comer c√≠clico -->
        <div class="card mb-4">
            <div class="card-header bg-info">
                4.3. Modelo de "Pensar-Comer" c√≠clico
            </div>
            <div class="card-body">
                <p>
                    En esta variante, cada fil√≥sofo alterna entre pensar y comer en un ciclo fijo
                    o programado, de manera que los recursos se distribuyen en intervalos predecibles.
                    Este enfoque se usa en sistemas de tiempo real donde los procesos necesitan
                    sincronizarse en intervalos regulares.
                </p>
                <p>
                    Ejemplo simplificado:
                </p>
                <pre class="bg-dark text-light p-3 small"><code>public final class FilosofoCiclico implements Runnable {

    private final int id;
    private final MonitorFilosofos monitor;

    public FilosofoCiclico(final int id, final MonitorFilosofos monitor) {
        this.id = id;
        this.monitor = monitor;
    }

    @Override
    public void run() {
        try {
            while (!Thread.currentThread().isInterrupted()) {
                // Pensar exactamente 1 segundo
                Thread.sleep(1000L);

                monitor.tomarTenedores(id);

                // Comer exactamente 2 segundos
                Thread.sleep(2000L);

                monitor.dejarTenedores(id);
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}</code></pre>

                <p>
                    Este modelo se relaciona con sistemas embebidos de monitoreo de sensores,
                    donde cada dispositivo accede a la red o a los recursos de procesamiento
                    en intervalos regulares, evitando bloqueos e injusticias prolongadas.
                </p>
            </div>
        </div>

        <!-- Variante 4: Soluci√≥n con sem√°foros y portero (FilosofoConSemaforos) -->
        <div class="card mb-4">
            <div class="card-header bg-secondary text-white">
                4.4. Variante completa con sem√°foros y portero (<code>FilosofoConSemaforos</code>)
            </div>
            <div class="card-body">
                <p>
                    En esta variante implementamos la cena de los fil√≥sofos √∫nicamente con
                    sem√°foros de <code>java.util.concurrent</code>. Cada tenedor se modela como
                    un <code>Semaphore</code> binario (permiso = 1) y se a√±ade un sem√°foro
                    adicional que act√∫a como <strong>portero</strong> con <code>N - 1</code> permisos.
                    De este modo, como m√°ximo se sientan <code>N - 1</code> fil√≥sofos
                    simult√°neamente, lo que evita el interbloqueo.
                </p>

                <h5>4.4.1. Clase <code>FilosofoConSemaforos</code></h5>
                <pre class="bg-dark text-light p-3 small"><code>import java.util.Random;
import java.util.concurrent.Semaphore;

/**
 * Implementaci√≥n de un fil√≥sofo usando √∫nicamente sem√°foros:
 * - Un array de Semaphore para los tenedores (uno por posici√≥n).
 * - Un Semaphore adicional (portero) con N-1 permisos para evitar deadlock.
 */
public final class FilosofoConSemaforos implements Runnable {

    private final int id;
    private final Semaphore[] tenedores;
    private final Semaphore portero;
    private final Random random = new Random();

    public FilosofoConSemaforos(final int id,
                                final Semaphore[] tenedores,
                                final Semaphore portero) {
        this.id = id;
        this.tenedores = tenedores;
        this.portero = portero;
    }

    private int izquierda() {
        return id;
    }

    private int derecha() {
        return (id + 1) % tenedores.length;
    }

    private void pensar() throws InterruptedException {
        System.out.println("Fil√≥sofo " + id + " PENSANDO (sem√°foros)...");
        Thread.sleep(random.nextInt(2000) + 500L);
    }

    private void comer() throws InterruptedException {
        System.out.println("Fil√≥sofo " + id + " COMIENDO (sem√°foros) üçù");
        Thread.sleep(random.nextInt(2000) + 500L);
    }

    @Override
    public void run() {
        try {
            while (!Thread.currentThread().isInterrupted()) {
                pensar();

                // El portero limita el n√∫mero de fil√≥sofos que pueden competir
                // por los tenedores simult√°neamente. Tiene N-1 permisos.
                portero.acquire();
                try {
                    // Adquirimos primero el tenedor izquierdo y luego el derecho.
                    // Cada tenedor es un sem√°foro binario (1 permiso).
                    tenedores[izquierda()].acquire();
                    tenedores[derecha()].acquire();
                    try {
                        comer();
                    } finally {
                        // Liberamos los tenedores en orden inverso
                        tenedores[derecha()].release();
                        tenedores[izquierda()].release();
                    }
                } finally {
                    // Dejamos libre un sitio en la mesa
                    portero.release();
                }
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            System.out.println("Fil√≥sofo " + id + " interrumpido (sem√°foros).");
        }
    }
}</code></pre>

                <h5 class="mt-3">4.4.2. Clase <code>CenaFilosofosSemaforos</code></h5>
                <p>
                    El m√©todo <code>main</code> crea un array de sem√°foros para los tenedores
                    y un sem√°foro adicional para el portero, con <code>N - 1</code> permisos.
                </p>
                <pre class="bg-dark text-light p-3 small"><code>import java.util.concurrent.Semaphore;

/**
 * Variante de la cena de los fil√≥sofos implementada con sem√°foros.
 */
public final class CenaFilosofosSemaforos {

    private CenaFilosofosSemaforos() {
        // Evitamos instanciaci√≥n
        }

    public static void main(String[] args) {
        final int N = 5;

        // Un sem√°foro binario por tenedor (1 permiso)
        final Semaphore[] tenedores = new Semaphore[N];
        for (int i = 0; i &lt; N; i++) {
            tenedores[i] = new Semaphore(1, true); // fairness=true para reducir starvation
        }

        // Sem√°foro "portero" con N-1 permisos
        final Semaphore portero = new Semaphore(N - 1, true);

        for (int i = 0; i &lt; N; i++) {
            final FilosofoConSemaforos f =
                    new FilosofoConSemaforos(i, tenedores, portero);
            final Thread t = new Thread(f, "FilosofoSem-" + i);
            t.start();
        }
    }
}</code></pre>

                <h5 class="mt-3">4.4.3. Interacci√≥n entre los sem√°foros</h5>
                <ul>
                    <li><strong>Array de sem√°foros de tenedores</strong>:
                        cada elemento del array <code>tenedores[i]</code> representa el tenedor
                        situado entre el fil√≥sofo <code>i</code> y el fil√≥sofo
                        <code>(i + 1) % N</code>. Al adquirir ambos sem√°foros, el fil√≥sofo
                        garantiza la exclusi√≥n mutua sobre los recursos f√≠sicos.</li>
                    <li><strong>Sem√°foro portero</strong>:
                        el sem√°foro <code>portero</code> con <code>N - 1</code> permisos asegura
                        que, como m√°ximo, <code>N - 1</code> fil√≥sofos puedan competir por los
                        tenedores al mismo tiempo. Esto rompe la posible espera circular
                        y elimina el deadlock.</li>
                    <li><strong>Equidad</strong>:
                        activar el par√°metro <code>fair</code> en los sem√°foros
                        (<code>new Semaphore(..., true)</code>) indica al runtime que utilice
                        una pol√≠tica FIFO para asignar permisos, reduciendo la probabilidad
                        de inanici√≥n.</li>
                </ul>
                <p>
                    Esta soluci√≥n ilustra c√≥mo los sem√°foros de <code>java.util.concurrent</code>
                    permiten expresar directamente las restricciones de concurrencia (n√∫mero m√°ximo
                    de hilos en secci√≥n cr√≠tica, exclusi√≥n mutua, orden de llegada) sin necesidad
                    de gestionar manualmente <code>wait()</code> y <code>notifyAll()</code>.
                </p>
            </div>
        </div>
    </section>
    <!-- SECCI√ìN 5: ENTREGA Y DOCUMENTACI√ìN -->
    <section id="entrega" class="mb-5">
        <h2>5. Entrega, documentaci√≥n y requisitos del proyecto</h2>

        <p class="lead">
            Para completar esta actividad, debes preparar correctamente el proyecto, documentarlo
            de forma profesional y enviarlo a trav√©s de Moodle en un archivo comprimido.
            La documentaci√≥n debe reflejar tanto el dise√±o concurrente como las pruebas con
            depuraci√≥n y pruebas unitarias.
        </p>

        <div class="card border-primary shadow-sm">
            <div class="card-header bg-primary text-white">
                Requisitos de la entrega
            </div>
            <div class="card-body">

                <h5 class="mt-3">üìÅ Estructura m√≠nima de archivos</h5>
                <ul>
                    <li><strong>C√≥digo fuente Java</strong> (carpeta <code>src/main/java</code> o similar) con:
                        <ul>
                            <li><code>MonitorFilosofos.java</code> (implementaci√≥n con monitor).</li>
                            <li><code>Filosofo.java</code> y <code>CenaFilosofos.java</code>.</li>
                            <li>Opcionalmente, variantes:
                                <code>MonitorConFootman.java</code>,
                                <code>FilosofoFootman.java</code>,
                                <code>FilosofoTimeout.java</code>,
                                <code>FilosofoCiclico.java</code>,
                                <code>FilosofoConSemaforos.java</code>,
                                <code>CenaFilosofosSemaforos.java</code>.
                            </li>
                        </ul>
                    </li>

                    <li><strong>Pruebas unitarias</strong> (carpeta <code>src/test/java</code>) con:
                        <ul>
                            <li><code>MonitorFilosofosTest.java</code> (invariantes y exclusi√≥n mutua).</li>
                            <li><code>FilosofoTest.java</code> (interrupciones / comportamiento b√°sico).</li>
                            <li><code>FilosofoConSemaforosTest.java</code> (portero y sem√°foros), en caso de implementar la variante.</li>
                        </ul>
                    </li>

                    <li><strong>Documentaci√≥n t√©cnica</strong> en formato PDF:
                        <ul>
                            <li><code>doc/memoria_tecnica.pdf</code>, incluyendo capturas de depuraci√≥n
                                y resumen de pruebas unitarias.</li>
                        </ul>
                    </li>

                    <li><strong>Archivo README</strong> (opcional pero recomendado):
                        <ul>
                            <li><code>README.md</code> con instrucciones de compilaci√≥n y ejecuci√≥n
                                (incluyendo c√≥mo ejecutar las pruebas JUnit).</li>
                        </ul>
                    </li>
                </ul>

                <h5 class="mt-4">üìù Contenido de la memoria t√©cnica</h5>
                <p>
                    La memoria t√©cnica deber√° presentarse en un documento PDF con una extensi√≥n
                    orientativa de entre 4 y 8 p√°ginas, escrita con un tono acad√©mico y siguiendo
                    una estructura coherente. Se recomienda el siguiente √≠ndice:
                </p>
                <ol>
                    <li><strong>Introducci√≥n</strong>
                        <ul>
                            <li>Descripci√≥n del problema de la cena de los fil√≥sofos.</li>
                            <li>Objetivos de la pr√°ctica y relaci√≥n con la programaci√≥n multihilo.</li>
                        </ul>
                    </li>
                    <li><strong>Dise√±o de la soluci√≥n</strong>
                        <ul>
                            <li>Explicaci√≥n de la arquitectura general.</li>
                            <li>Descripci√≥n de las clases principales y sus responsabilidades.</li>
                            <li>Decisiones de dise√±o sobre el uso de monitores y/o sem√°foros,
                                justificando la soluci√≥n elegida.</li>
                        </ul>
                    </li>
                    <li><strong>Implementaci√≥n concurrente</strong>
                        <ul>
                            <li>Detalle del funcionamiento de <code>MonitorFilosofos</code>:
                                estados, invariante, uso de <code>synchronized</code> y
                                <code>wait()</code>/<code>notifyAll()</code>.</li>
                            <li>Descripci√≥n de las variantes con sem√°foros y portero
                                (<code>FilosofoConSemaforos</code> y
                                <code>CenaFilosofosSemaforos</code>), en caso de implementarlas.</li>
                            <li>Justificaci√≥n de c√≥mo se evita el <em>deadlock</em> y c√≥mo se
                                reduce la <em>starvation</em>.</li>
                        </ul>
                    </li>
                    <li><strong>Pruebas y resultados</strong>
                        <ul>
                            <li>Descripci√≥n de las pruebas realizadas (escenarios de ejecuci√≥n,
                                n√∫mero de fil√≥sofos, repeticiones).</li>
                            <li>Resumen de las <strong>pruebas unitarias</strong> implementadas con JUnit
                                (casos de prueba, invariantes comprobadas y resultados).</li>
                            <li>Selecci√≥n de <strong>capturas de pantalla del depurador</strong>
                                (ver secci√≥n 6 de este tutorial), se√±alando estados de los hilos,
                                valores del array <code>estado[]</code> y situaciones de espera.</li>
                            <li>Comentarios sobre el comportamiento observado (equidad, aparici√≥n
                                o ausencia de bloqueos, etc.).</li>
                        </ul>
                    </li>
                    <li><strong>Conclusiones y trabajo futuro</strong>
                        <ul>
                            <li>Resumen de lo aprendido sobre programaci√≥n multihilo en Java.</li>
                            <li>Posibles mejoras o extensiones (cambio a <code>ExecutorService</code>,
                                monitorizaci√≥n de estad√≠sticas, interfaz gr√°fica, etc.).</li>
                        </ul>
                    </li>
                </ol>

                <h5 class="mt-4">üìö Calidad del c√≥digo y documentaci√≥n interna</h5>
                <ul>
                    <li>El c√≥digo debe compilar sin errores ni <em>warnings</em> innecesarios.</li>
                    <li>Deben utilizarse nombres de clases, m√©todos y variables significativos
                        (<code>MonitorFilosofos</code>, <code>FilosofoConSemaforos</code>,
                        <code>tomarTenedores</code>, etc.).</li>
                    <li>Los m√©todos principales de sincronizaci√≥n deben estar comentados, indicando:
                        <ul>
                            <li>Qu√© condici√≥n l√≥gica est√°n comprobando.</li>
                            <li>Qu√© invariante garantizan.</li>
                            <li>Qu√© estados de los hilos intervienen (<em>RUNNABLE</em>,
                                <em>WAITING</em>, etc.).</li>
                        </ul>
                    </li>
                    <li>Se valorar√° positivamente el uso de comentarios tipo Javadoc
                        (<code>/** ... */</code>) y la generaci√≥n opcional de la documentaci√≥n
                        con la herramienta <code>javadoc</code>.</li>
                </ul>

                <h5 class="mt-4">üì¶ Formato de entrega</h5>
                <p>
                    Todo el proyecto deber√° comprimirse en un √∫nico archivo con el formato:
                </p>
                <pre class="bg-light p-2"><code>nombre-apellidos-multihilo.zip</code></pre>
                <p>
                    Puedes utilizar formatos <strong>.zip</strong> o <strong>.rar</strong>.
                    No se aceptar√°n carpetas sueltas ni enlaces externos.
                </p>

                <h5 class="mt-4">üì§ C√≥mo enviar la tarea en Moodle</h5>
                <ol>
                    <li>Accede al curso correspondiente.</li>
                    <li>Entra en la tarea titulada
                        <strong>‚ÄúActividad: Programaci√≥n Multihilo ‚Äì Cena de los Fil√≥sofos‚Äù</strong>.
                    </li>
                    <li>Haz clic en <strong>‚ÄúAgregar entrega‚Äù</strong>.</li>
                    <li>Sube el archivo comprimido (<code>.zip</code> o <code>.rar</code>).</li>
                    <li>Guarda los cambios y confirma la entrega.</li>
                </ol>

                <h5 class="mt-4">‚úî Criterios m√≠nimos para que la entrega sea evaluada</h5>
                <ul>
                    <li>El programa debe compilar y ejecutarse correctamente desde l√≠nea de comandos
                        (o desde el IDE indicado por el profesor).</li>
                    <li>El c√≥digo debe incluir comentarios explicativos de la l√≥gica de concurrencia
                        y del uso de las primitivas de sincronizaci√≥n.</li>
                    <li>Deben existir <strong>pruebas unitarias</strong> que verifiquen al menos las
                        invariantes b√°sicas del monitor.</li>
                    <li>La memoria t√©cnica debe incluir capturas de depuraci√≥n y una secci√≥n de
                        pruebas y resultados claramente redactada.</li>
                    <li>El archivo comprimido debe tener la estructura solicitada y un nombre que
                        identifique claramente al autor o al grupo.</li>
                </ul>

                <div class="alert alert-info mt-4">
                    üí° <strong>Consejo:</strong> Antes de comprimir la carpeta, prueba a ejecutar
                    el programa y las pruebas desde la l√≠nea de comandos tal y como lo recibir√° el profesor.
                    Verifica que no dependes de rutas absolutas ni de configuraciones locales
                    de tu IDE.
                </div>

            </div>
        </div>

    </section>

    <!-- SECCI√ìN 6: Capturas con el depurador -->
    <section id="debugger" class="mb-5">
        <h2>6. Capturas de pantalla usando el depurador</h2>
        <p class="lead">
            Las capturas de pantalla del depurador forman parte del apartado
            <strong>‚ÄúPruebas y resultados‚Äù</strong> de la memoria t√©cnica. Deben ilustrar el
            comportamiento real de los hilos y del monitor durante la ejecuci√≥n.
        </p>

        <div class="card border-secondary shadow-sm">
            <div class="card-header bg-secondary text-white">
                Indicaciones para generar capturas de calidad
            </div>

            <div class="card-body">
                <h5>1. Configurar puntos de ruptura</h5>
                <ul>
                    <li>Coloca un breakpoint en <code>Filosofo.run()</code>, justo antes de llamar a <code>monitor.tomarTenedores()</code>.</li>
                    <li>Pon otro en <code>MonitorFilosofos.tomarTenedores()</code> y, opcionalmente, en
                        <code>intentarComer()</code> y <code>dejarTenedores()</code>.</li>
                </ul>

                <h5>2. Ejecutar en modo Depuraci√≥n</h5>
                <p>
                    Lanza la clase <code>CenaFilosofos</code> en modo Debug y captura:
                </p>
                <ul>
                    <li>La lista de hilos activos (por ejemplo, <code>Filosofo-0</code>, <code>Filosofo-1</code>‚Ä¶).</li>
                    <li>Un hilo detenido en un breakpoint, mostrando su pila de llamadas (stack trace).</li>
                </ul>

                <h5>3. Inspeccionar variables</h5>
                <p>
                    Entra paso a paso en el monitor e inspecciona el array <code>estado[]</code>.
                </p>
                <ul>
                    <li>Muestra en la captura los valores de <code>estado[i]</code> y los de sus vecinos
                        (<code>estado[izquierda(i)]</code> y <code>estado[derecha(i)]</code>).</li>
                    <li>Incluye en la memoria una breve explicaci√≥n sobre la situaci√≥n de concurrencia
                        que se observa.</li>
                </ul>

                <h5>4. Capturas de hilos en WAITING / BLOCKED</h5>
                <p>
                    Permite que varios fil√≥sofos esperen en <code>wait()</code> y captura:
                </p>
                <ul>
                    <li>Hilos en estado <strong>WAITING</strong> o <strong>BLOCKED</strong> en la vista de hilos del IDE.</li>
                    <li>La l√≠nea concreta donde est√°n suspendidos dentro del monitor.</li>
                </ul>

                <h5>5. Recomendaci√≥n para la memoria</h5>
                <p>
                    Cada captura debe acompa√±arse de un pie explicativo, por ejemplo:
                </p>
                <blockquote class="blockquote">
                    ‚ÄúFigura X.Y ‚Äì Fil√≥sofo 2 en estado HAMBRIENTO esperando a que el vecino
                    libere los tenedores. El hilo est√° en WAITING dentro del monitor.‚Äù
                </blockquote>
            </div>
        </div>
    </section>

    <!-- SECCI√ìN 7: Pruebas unitarias -->
    <section id="pruebas" class="mb-5">
        <h2>7. Pruebas unitarias de la l√≥gica concurrente</h2>
        <p class="lead">
            Adem√°s de la ejecuci√≥n normal, es recomendable realizar pruebas unitarias que verifiquen
            el correcto funcionamiento del monitor y reduzcan el riesgo de errores t√≠picos de concurrencia.
            Se utilizar√° JUnit para automatizar las comprobaciones.
        </p>

        <div class="card border-primary shadow-sm">
            <div class="card-header bg-primary text-white">
                Tipos de pruebas recomendadas
            </div>

            <div class="card-body">
                <h5>1. Pruebas de invariantes del monitor</h5>
                <p>
                    Se instancian pocos fil√≥sofos (por ejemplo, 3) y se verifican las transiciones de estado
                    sin crear hilos reales:
                </p>
                <ul>
                    <li><code>estado[i]</code> pasa a COMIENDO si no hay vecinos comiendo.</li>
                    <li>Tras <code>dejarTenedores(i)</code>, el fil√≥sofo vuelve a PENSANDO.</li>
                </ul>

<pre class="bg-light p-3"><code>@Test
public void testTransicionBasica() throws InterruptedException {
    MonitorFilosofos m = new MonitorFilosofos(3);
    m.tomarTenedores(0);
    assertEquals(MonitorFilosofos.COMIENDO, m.getEstado(0));
    m.dejarTenedores(0);
    assertEquals(MonitorFilosofos.PENSANDO, m.getEstado(0));
}</code></pre>

                <h5>2. Pruebas de exclusi√≥n mutua</h5>
                <p>
                    Se comprueba que nunca hay dos vecinos comiendo simult√°neamente:
                </p>

<pre class="bg-light p-3"><code>for (int i = 0; i &lt; N; i++) {
    assertFalse(m.getEstado(i) == MonitorFilosofos.COMIENDO
        &amp;&amp; m.getEstado((i + 1) % N) == MonitorFilosofos.COMIENDO);
}</code></pre>

                <h5>3. Pruebas de interrupci√≥n</h5>
                <p>
                    Se verifica que los hilos <code>Filosofo</code> terminan correctamente cuando se llama
                    a <code>interrupt()</code>, es decir, que salen del bucle de <code>run()</code> sin bloquearse.
                </p>

                <h5>4. Pruebas para la variante con sem√°foros</h5>
                <ul>
                    <li>Comprobar que el sem√°foro ‚Äúportero‚Äù se inicializa con <code>N - 1</code> permisos.</li>
                    <li>Asegurar que no hay <code>N</code> fil√≥sofos simult√°neamente en la secci√≥n COMIENDO.</li>
                </ul>

                <h5>5. Estructura recomendada del paquete de pruebas</h5>
<pre class="bg-light p-3"><code>src/
 ‚îú‚îÄ‚îÄ main/java/...
 ‚îî‚îÄ‚îÄ test/java/
      ‚îú‚îÄ‚îÄ MonitorFilosofosTest.java
      ‚îú‚îÄ‚îÄ FilosofoTest.java
      ‚îî‚îÄ‚îÄ FilosofoConSemaforosTest.java</code></pre>

                <p class="mt-3">
                    En la memoria t√©cnica, dentro del apartado <strong>‚ÄúPruebas y resultados‚Äù</strong>,
                    incluye un breve resumen de las pruebas implementadas, indicando qu√© verifican,
                    si han pasado correctamente y qu√© garant√≠as ofrecen sobre el comportamiento
                    concurrente del sistema.
                </p>
            </div>
        </div>
    </section>

</div>

<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>
